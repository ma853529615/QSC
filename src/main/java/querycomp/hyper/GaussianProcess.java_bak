package querycomp.hyper;

import java.util.ArrayList;  
import java.util.List;  

public class GaussianProcess {  
    private List<Double> xSamples;  
    private List<Double> ySamples;  
    private double noise; // 噪声水平  
    private final double kernelVariance = 1.0; // 核函数的方差  
    private final double lengthScale = 1.0; // 长度尺度  

    public GaussianProcess(double noise) {  
        this.xSamples = new ArrayList<>();  
        this.ySamples = new ArrayList<>();  
        this.noise = noise;  
    }  

    private double kernel(double x1, double x2) {  
        return kernelVariance * Math.exp(-Math.pow(x1 - x2, 2) / (2 * Math.pow(lengthScale, 2)));  
    }  
    
    // 更新训练数据  
    public void updateSamples(double x, double y) {  
        xSamples.add(x);  
        ySamples.add(y);  
    }  
    
    public double[] predicts(double x) {  
        StandardScaler x_scaler = new StandardScaler();  
        StandardScaler y_scaler = new StandardScaler();  
        
        // 获取样本数据  
        double[] x_array = xSamples.stream().mapToDouble(Double::doubleValue).toArray();  
        double[] y_array = ySamples.stream().mapToDouble(Double::doubleValue).toArray();  
    
        // 拟合以获取均值和标准差  
        x_scaler.fit(x_array);  
        y_scaler.fit(y_array);  
    
        // 标准化输入值  
        double[] normalizedX = x_scaler.transform(new double[]{x});  
        double normalizedXValue = normalizedX[0]; // 标准化后的预测值  
    
        // 标准化样本数据  
        double[] normalizedY = y_scaler.transform(y_array);  
        double[] normalizedX_array = x_scaler.transform(x_array);  
    
        int size = xSamples.size();  
        double cov;  
    
        if (size == 0) {  
            return new double[]{0, Double.MAX_VALUE}; // 没有样本时的返回值  
        }  
    
        // 计算协方差矩阵 K 和对应的向量 k*  
        double[][] K = new double[size][size];  
        double[] kStar = new double[size];  
    
        // 计算样本间的协方差和预测点的协方差  
        for (int i = 0; i < size; i++) {  
            for (int j = 0; j < size; j++) {  
                K[i][j] = kernel(normalizedX_array[i], normalizedX_array[j]); // 使用标准化后的样本  
            }  
            kStar[i] = kernel(normalizedXValue, normalizedX_array[i]); // 预测点与样本的协方差  
        }  
    
        // 为协方差矩阵添加噪声项  
        for (int i = 0; i < size; i++) {  
            K[i][i] += noise; // 在对角线上加上噪声  
        }  
    
        double[][] K_inv = inverse(K); // 计算协方差矩阵的逆  
    
        // 计算预测均值  
        double kStarMean = 0;  
        for (int i = 0; i < size; i++) {  
            kStarMean += kStar[i] * K_inv[i][0]; // 使用 K_inv 计算均值  
        }  
    
        // 关注 y 的缩放和偏移  
        kStarMean = y_scaler.inverse_transform(new double[]{kStarMean})[0]; // 反标定均值  
        cov = kernel(normalizedXValue, normalizedXValue) + noise; // 先计算 noise  
        for (int i = 0; i < size; i++) {  
            cov -= kStar[i] * K_inv[i][0]; // 减去过程  
        }  
    
        // 确保方差是原始值的方差  
        cov *= Math.pow(y_scaler.scale_, 2); // 根据 y 的扩展缩放  
    
        return new double[]{kStarMean, cov}; // 返回预测均值和协方差  
    }
    public double[] predict(double[] x){
        double[] mean = new double[x.length];
        double[] cov = new double[x.length];
        for(int i=0; i<x.length; i++){
            double[] prediction = predicts(x[i]);
            mean[i] = prediction[0];
        }
        return mean;
    }
    
    // 实现矩阵求逆的简单方法（使用高斯消元法或其他方法）  
    private double[][] inverse(double[][] matrix) {  
        int n = matrix.length;  
        double[][] result = new double[n][n];  
        
        // 创建单位矩阵  
        for(int i = 0; i < n; i++) {  
            for(int j = 0; j < n; j++) {  
                result[i][j] = (i == j) ? 1+1e-6 : 1e-6; // 1e-6 是一个很小的数，用于数值稳定性
            }  
        }
    
        // 高斯消元法求逆  
        for (int i = 0; i < n; i++) {  
            double pivot = matrix[i][i];  
            for (int j = 0; j < n; j++) {  
                matrix[i][j] /= pivot; // 标准化行  
                result[i][j] /= pivot;  
            }  
            for (int j = 0; j < n; j++) {  
                if (j != i) {  
                    double factor = matrix[j][i];  
                    for (int k = 0; k < n; k++) {  
                        matrix[j][k] -= factor * matrix[i][k]; // 消元  
                        result[j][k] -= factor * result[i][k];  
                    }  
                }  
            }  
        }  
        
        return result;  
    }
    // 计算UCB采集函数  
    public double calculateUCB(double x, double beta) {  
        double[] prediction = predict(x);  
        double mean = prediction[0];  
        double stdDev = Math.sqrt(prediction[1]);  

        return mean + beta * stdDev; // UCB公式  
    }  

    // 计算PI采集函数  
    public double calculatePI(double x) {  
        double[] prediction = predict(x);  
        double mean = prediction[0];  
        double stdDev = Math.sqrt(prediction[1]);  
        double bestKnownValue = max(ySamples); // 最优已知值  

        // 预期改进公式  
        return Math.max(0, mean - bestKnownValue) / stdDev;  
    }  

    // 返回已知样本的最大值  
    public double max(List<Double> values) {  
        return values.stream().max(Double::compareTo).orElse(Double.NEGATIVE_INFINITY);  
    }  
    // return the x value of the maximum y value
    public double max_x() {  
        double max = max(ySamples);
        int index = ySamples.indexOf(max);
        return xSamples.get(index);
    }
    public double predict_max(double lowb, double upb) {  
        double max = max(ySamples);
        for(double i=lowb; i<=upb; i+=1) {  
            double[] prediction = predict(i);  
            double mean = prediction[0];  
            if(mean > max) {  
                max = mean;  
            }
        }
        return max;
    }
    public List<Double> getYSamples() {  
        return ySamples; // 新增方法，获取已评估的 y 值  
    }  
}

class StandardScaler {  
    private double mean;  
    private double std;  

    // 适配器方法，计算均值和标准差  
    public void fit(double[] data) {  
        mean = calculateMean(data);  
        std = calculateStd(data, mean);  
    }  

    // 转换数据，将其标准化  
    public double[] transform(double[] data) {  
        double[] standardizedData = new double[data.length];  
        for (int i = 0; i < data.length; i++) {  
            standardizedData[i] = (data[i] - mean) / std;  
        }  
        return standardizedData;  
    }  

    // Helper method: 计算均值  
    private double calculateMean(double[] data) {  
        double sum = 0;  
        for (double num : data) {  
            sum += num;  
        }  
        return sum / data.length;  
    }  

    // Helper method: 计算标准差  
    private double calculateStd(double[] data, double mean) {  
        double sumSquaredDiffs = 0;  
        for (double num : data) {  
            sumSquaredDiffs += Math.pow(num - mean, 2);  
        }  
        return Math.sqrt(sumSquaredDiffs / data.length);  
    }  

}