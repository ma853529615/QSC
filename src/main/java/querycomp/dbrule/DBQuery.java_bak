package querycomp.dbrule;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Vector;

import querycomp.dbrule.*;

public class DBQuery {
    public int id;
    public Vector<Predicate> head = new Vector<Predicate>();
    public Vector<Predicate> body = new Vector<Predicate>();
    protected HashMap<String, Vector<Argument>> joinMap = new HashMap<String, Vector<Argument>>();
    protected Vector<Argument> constantsBody = new Vector<Argument>();
    protected Vector<Predicate> allPredicates = new Vector<Predicate>();

    public DBQuery(String rule, int id){
        this.id = id;
        String[] parts = rule.replace(".", "").split(":-");
        String[] head_string = parts[0].trim().split(", ");
        String[] body_strings = parts[1].trim().split(", ");
        String[][] head_argss = new String[head_string.length][];
        // head_string is formated as "functor(arg1, arg2, ...)", it may has the constant in the arg, like "functor(1, arg1, ...)"
        // we view a item as a constant if it is not a digital
        // get all the functor, args and constants in the head, and store thier positions
        int s = 0;
        for(String head_pred:head_string){
            String[] head_parts = head_pred.split("\\(");
            String head_functor = head_parts[0].trim();
            String[] head_args = head_parts[1].trim().split("\\)")[0].split(",");
            head_argss[s++] = head_args;
            // construct the Argument array for the head
            Vector<Argument> head_args_array = new Vector<Argument>();
            Integer pred_id = 0;
            for(int i = 0; i < head_args.length; i++){
                String arg = head_args[i];
                if(!Argument.checkVariable(arg)){

                    head_args_array.add(new Argument(arg, true, pred_id, i));
                    //constants.add(head_args_array[i]);
                }else{
                    // argSet.add(arg);
                    head_args_array.add(new Argument(arg, false, pred_id, i));
                    if (!joinMap.containsKey(head_args_array.get(i).name)){
                        joinMap.put(head_args_array.get(i).name, new Vector<Argument>());
                    }
                    //joinMap.get(head_args_array[i]).add(head_args_array[i]);
                }
            }
        
            pred_id++;
            Predicate this_head = new Predicate(head_functor, (Argument[])head_args_array.toArray(new Argument[head_args_array.size()]));
            allPredicates.add(this_head);
        }
        HashMap<String, Integer> predcnt = new HashMap<String, Integer>();

        for (String body_string : body_strings){
            String[] body_parts = body_string.split("\\(");
            String body_functor = body_parts[0].trim();
            String[] body_args = new String[0];
            try{
                body_args = body_parts[1].trim().split("\\)")[0].split(",");
            }
            catch(Exception e){
                System.out.println("body_string: "+body_string);
            }
            if(body_functor.contains("=")){
                
                String constant = "";
                int k = 0;
                for(String arg: body_args){
                    if(arg.matches("^[0-9]+$")){
                        constant = arg;
                        continue;
                    }
                    int i = 0;
                    for(String[] head_args:head_argss){
                        for(String argh:head_args){
                            if(arg.equals(argh)){
                                k=i;
                            }
                            i++;
                        }
                    }
                }
                head.args[k].name = constant;
                head.args[k].isConstant = true;
                continue;
            }
            Vector<Argument> body_args_array = new Vector<Argument>();
            for(int i = 0; i < body_args.length; i++){
                String arg = body_args[i];
                if(!Argument.checkVariable(arg)){

                    body_args_array.add(new Argument(arg, true, pred_id, i));
                    try{
                        constantsBody.add(body_args_array.get(i));                }catch(Exception e){
                        System.out.println("body_args_array.get(i).name: "+body_args_array.get(i).name);
                    }
                }else{
                    // argSet.add(arg);
                    body_args_array.add(new Argument(arg, false, pred_id, i));
                    try{
                        if (!joinMap.containsKey(body_args_array.get(i).name)){
                            joinMap.put(body_args_array.get(i).name, new Vector<Argument>());
                        }
                    }catch(Exception e){
                        System.out.println("body_args_array.get(i).name: "+body_args_array.get(i).name);
                    }
                    joinMap.get(body_args_array.get(i).name).add(body_args_array.get(i));
                }
            }
            
            pred_id++;
            // if has duplicate predicates, tag it and record its duplicate index
            if(!predcnt.containsKey(body_functor)){
                predcnt.put(body_functor, 1);
            }else{
                predcnt.put(body_functor, predcnt.get(body_functor)+1);
            }
            Predicate pred = new Predicate(body_functor, (Argument[])body_args_array.toArray(new Argument[body_args_array.size()]));
            allPredicates.add(pred);
            body.add(pred);
        }
        //set the duplicate index in the predicate
        for (Predicate pred : body){
            Integer cunt = predcnt.get(pred.functor);
            if(cunt>1){            
                pred.duplicateID = cunt;
                predcnt.put(pred.functor, cunt-1);
            }
        }
    }
    public boolean hasDuplicatePredicates(){
        HashSet<String> predSet = new HashSet<String>();
        for (Predicate pred : allPredicates){
            if (predSet.contains(pred.functor)){
                return true;
            }
            predSet.add(pred.functor);
        }
        return false;
    }
    @Override
    public String toString(){
        String str = head.functor + "(";
        for (int i = 0; i < head.args.length; i++){
            str += head.args[i].name;
            if (i < head.args.length - 1){
                str += ",";
            }
        }
        str += ") :- ";
        for (int i = 0; i < body.size(); i++){
            Predicate pred = body.get(i);
            str += pred.functor + "(";
            for (int j = 0; j < pred.args.length; j++){
                str += pred.args[j].name;
                if (j < pred.args.length - 1){
                    str += ",";
                }
            }
            str += ")";
            if (i < body.size() - 1){
                str += ", ";
            }
        }
        return str;
    }
    public String toString_Map(String[] mapping){
        String str = head.functor + "(";
        for (int i = 0; i < head.args.length; i++){
            if(head.args[i].isConstant){
                str += mapping[Integer.parseInt(head.args[i].name)];
            }else{
                str += head.args[i].name;
            }
            if (i < head.args.length - 1){
                str += ", ";
            }
        }
        str.replace(":", "$");
        str += ") :- ";
        String str2 = "";
        for (int i = 0; i < body.size(); i++){
            Predicate pred = body.get(i);
            str2 += pred.functor + "(";
            for (int j = 0; j < pred.args.length; j++){
                if(pred.args[j].isConstant){
                    str2 += mapping[Integer.parseInt(pred.args[j].name)];
                }else{
                    str2 += pred.args[j].name;
                }
                if (j < pred.args.length - 1){
                    str2 += ", ";
                }
            }
            str2 += ")";
            if (i < body.size() - 1){
                str2 += ", ";
            }
        }
        str2.replace(":", "$");
        return str+str2;
    }
    protected Vector<Vector<Argument>> getHeadJoins(){
        Vector<Vector<Argument>> joins = new Vector<Vector<Argument>>();
        for (Map.Entry<String, Vector<Argument>> entry : joinMap.entrySet()){
            Vector<Argument> join_arg = entry.getValue();
            Vector<Argument> join = new Vector<Argument>();

            if(join_arg.size() >=2 || (join_arg.get(0).predict_id == 0&&join_arg.size() >= 1)){
                for(Argument arg: join_arg){
                    if(arg.predict_id>0){   
                        join.add(arg);
                    }
                }
                joins.add(join);
            }

        }
        return joins;
    }
    // get the body joins
    // only return the joins has at least 2 arguments
    protected Vector<Vector<Argument>> getJoins(){
        Vector<Vector<Argument>> joins = new Vector<Vector<Argument>>();
        for (Map.Entry<String, Vector<Argument>> entry : joinMap.entrySet()){
            Vector<Argument> join_arg = entry.getValue();
            Vector<Argument> join = new Vector<Argument>();
            if(join_arg.size() < 2){
                continue;
            }
            for(Argument arg: join_arg){
                if(arg.predict_id>0){
                    join.add(arg);
                }
            }
            joins.add(join);
        }
        return joins;
    }
    // TODO: duplicate table name
    public String inferRuleAndUpdateTarget(DBRule rule, Predicate target_pred, String target_column, String value){
        String rule_sql = rule.rule2SQL(true, false);
        String sql = "UPDATE "+target_pred.functor+" SET "+target_column+"=";
        if(target_column.equals("count")){
            sql += target_column+"+1";
        }else{
            sql += "\'"+value+"\'";
        }
        sql += " WHERE EXISTS "+ "(SELECT 1 FROM ("+rule_sql+") AS temp WHERE ";
        String[] target_columns = target_pred.getColumns();
        for(int i = 0; i < target_columns.length; i++){
            sql += target_pred.functor+"."+target_columns[i]+"=temp."+rule.head.functor+"_"+(i+1);
            if(i < target_columns.length - 1){
                sql += " AND ";
            }
        }
        sql += ");";
        return sql;
    }
    // make sure the infered head is exsit in the db
    public String rule2SQL_where_head(boolean tag){
        String sql = " FROM ";
       // get the body functors
       for (int i = 0; i < body.size(); i++){
           Predicate pred = body.get(i);
           sql += pred.fromCls();
           if (i < body.size() - 1){
               sql += ", ";
           }
       }
       String where_cls = "";
       where_cls += " WHERE ";
       // get the joins
       Vector<Vector<Argument>> joins = getHeadJoins();
       for (int i = 0; i < joins.size(); i++){
           Vector<Argument> join = joins.get(i);
           Argument arg1 = join.get(0);
           Predicate pred1 = allPredicates.get(arg1.predict_id);
           for(int j = 1; j < join.size(); j++){
               Argument arg = join.get(j);
               Predicate pred = allPredicates.get(arg.predict_id);
               where_cls += (pred.bodySelCls()+"."+pred.functor + "_" + (arg.position+1) + " = " + pred1.bodySelCls()+"."+pred1.functor + "_" + (arg1.position+1));
               if ((j < join.size() - 1)||(i < joins.size() - 1)){
                   where_cls += " AND ";
               }
               // where_cls += " AND ";
           }
       }
       
       // get all the constants predicates 
       if(constantsBody.size() > 0 & !(where_cls.endsWith("AND ")) & joins.size() > 0){
               where_cls += " AND ";
       }
       for (int i = 0; i < constantsBody.size(); i++){
           Argument constant = constantsBody.get(i);
           Predicate pred = allPredicates.get(constant.predict_id);
           where_cls += (pred.bodySelCls()+"."+pred.functor + "_" + (constant.position+1) + " = "  + constant.name);
           if (i < constantsBody.size() - 1){
               where_cls += " AND ";
           }
       }

       if(tag){
           if(!(where_cls.endsWith("AND ") || where_cls.endsWith("WHERE "))){
               where_cls += " AND ";
           }
           for (int i = 0; i < body.size(); i++){
               Predicate pred = body.get(i);
               where_cls += pred.bodySelCls() + ".exists = 1";
               if (i < body.size() - 1){
                   where_cls += " AND ";
               }
           }
       }
       // if (!(joins.size() == 0 && constantsBody.size() == 0 && !tag && !has_target)){
       //     sql += where_cls;
       // }
       while(where_cls.endsWith("AND ")){
           where_cls = where_cls.substring(0, where_cls.length()-5);
       }
       if(!where_cls.equals(" WHERE ")){
           sql += where_cls;
       }
       return sql;
   }

    public String rule2SQL_where(boolean tag){
        String sql = " FROM ";
       // get the body functors
       for (int i = 0; i < body.size(); i++){
           Predicate pred = body.get(i);
           sql += pred.fromCls();
           if (i < body.size() - 1){
               sql += ", ";
           }
       }
       String where_cls = "";
       where_cls += " WHERE ";
       // get the joins
       Vector<Vector<Argument>> joins = getJoins();
       for (int i = 0; i < joins.size(); i++){
           Vector<Argument> join = joins.get(i);
           Argument arg1 = join.get(0);
           Predicate pred1 = allPredicates.get(arg1.predict_id);
           for(int j = 1; j < join.size(); j++){
               Argument arg = join.get(j);
               Predicate pred = allPredicates.get(arg.predict_id);
               where_cls += (pred.bodySelCls()+"."+pred.functor + "_" + (arg.position+1) + " = " + pred1.bodySelCls()+"."+pred1.functor + "_" + (arg1.position+1));
               if ((j < join.size() - 1)||(i < joins.size() - 1)){
                   where_cls += " AND ";
               }
               // where_cls += " AND ";
           }
       }
       
       // get all the constants predicates 
       if(constantsBody.size() > 0 & !(where_cls.endsWith("AND ")) & joins.size() > 0){
               where_cls += " AND ";
       }
       for (int i = 0; i < constantsBody.size(); i++){
           Argument constant = constantsBody.get(i);
           Predicate pred = allPredicates.get(constant.predict_id);
           where_cls += (pred.bodySelCls()+"."+pred.functor + "_" + (constant.position+1) + " = "  + constant.name);
           if (i < constantsBody.size() - 1){
               where_cls += " AND ";
           }
       }

       if(tag){
           if(!(where_cls.endsWith("AND ") || where_cls.endsWith("WHERE "))){
               where_cls += " AND ";
           }
           for (int i = 0; i < body.size(); i++){
               Predicate pred = body.get(i);
               where_cls += pred.bodySelCls() + ".exists = 1";
               if (i < body.size() - 1){
                   where_cls += " AND ";
               }
           }
       }
       // if (!(joins.size() == 0 && constantsBody.size() == 0 && !tag && !has_target)){
       //     sql += where_cls;
       // }
       while(where_cls.endsWith("AND ")){
           where_cls = where_cls.substring(0, where_cls.length()-5);
       }
       if(!where_cls.equals(" WHERE ")){
           sql += where_cls;
       }
       return sql;
   }
    public String rule2SQL_where(boolean tag, int[] target_gold){
         String sql = " FROM ";
        // get the body functors
        for (int i = 0; i < body.size(); i++){
            Predicate pred = body.get(i);
            sql += pred.fromCls();
            if (i < body.size() - 1){
                sql += ", ";
            }
        }
        String where_cls = "";
        where_cls += " WHERE ";
        // get the joins
        Vector<Vector<Argument>> joins = getJoins();
        for (int i = 0; i < joins.size(); i++){
            Vector<Argument> join = joins.get(i);
            Argument arg1 = join.get(0);
            Predicate pred1 = allPredicates.get(arg1.predict_id);
            for(int j = 1; j < join.size(); j++){
                Argument arg = join.get(j);
                Predicate pred = allPredicates.get(arg.predict_id);
                where_cls += (pred.bodySelCls()+"."+pred.functor + "_" + (arg.position+1) + " = " + pred1.bodySelCls()+"."+pred1.functor + "_" + (arg1.position+1));
                if ((j < join.size() - 1)||(i < joins.size() - 1)){
                    where_cls += " AND ";
                }
                // where_cls += " AND ";
            }
        }

        
        // get all the constants predicates 
        if(constantsBody.size() > 0 & !(where_cls.endsWith("AND ")) & joins.size() > 0){
                where_cls += " AND ";
        }
        for (int i = 0; i < constantsBody.size(); i++){
            Argument constant = constantsBody.get(i);
            Predicate pred = allPredicates.get(constant.predict_id);
            where_cls += (pred.bodySelCls()+"."+pred.functor + "_" + (constant.position+1) + " = "  + constant.name);
            if (i < constantsBody.size() - 1){
                where_cls += " AND ";
            }
        }

        if(tag){
            if(!(where_cls.endsWith("AND ") || where_cls.endsWith("WHERE "))){
                where_cls += " AND ";
            }
            for (int i = 0; i < body.size(); i++){
                Predicate pred = body.get(i);
                where_cls += pred.bodySelCls() + ".exists = 1";
                if (i < body.size() - 1){
                    where_cls += " AND ";
                }
            }
        }

 
        // get the head Arguments and Constant
        Argument[] head_args = head.args;
        where_cls += " AND ";
        for (int i = 0; i < head_args.length; i++){
            Argument arg = head_args[i];
            if (!arg.isConstant){
                try{
                    Argument target_arg = joinMap.get(arg.name).get(0);
                    Predicate target_pred = allPredicates.get(target_arg.predict_id);
                    where_cls += (target_pred.bodySelCls()+"."+target_pred.functor+'_'+(target_arg.position+1)+"= " + target_gold[i]);
                }catch(Exception e){
                    System.out.println("arg.name: "+arg.name);
                }
            }
            if (i < head_args.length - 1){
                where_cls += " AND ";
            }
        }
        // if (!(joins.size() == 0 && constantsBody.size() == 0 && !tag && !has_target)){
        //     sql += where_cls;
        // }
        while(where_cls.endsWith("AND ")){
            where_cls = where_cls.substring(0, where_cls.length()-5);
        }
        if(!where_cls.equals(" WHERE ")){
            sql += where_cls;
        }
        return sql;
    }
    // TODO: duplicate table name

    public HashMap<String, String> getTarget2bodyColumns(){
        HashMap<String, String> target2bodyColumns = new HashMap<String, String>();
        for (int i = 0; i < head.args.length; i++){
            Argument arg = head.args[i];
            if (arg.isConstant){
                target2bodyColumns.put(head.functor + "_" + (i+1), "\'" + arg.name + "\'");
            }else{
                Argument target_arg = joinMap.get(arg.name).get(0);
                Predicate target_pred = allPredicates.get(target_arg.predict_id);
                target2bodyColumns.put(head.functor + "_" + (i+1), target_pred.functor + "_" + (target_arg.position+1));
            }
        }
        return target2bodyColumns;
    }
    public String query2SQL(){
        String sql = "SELECT ";
        sql += " * ";
        sql += " FROM ";
        // get the body functors
        for (int i = 0; i < body.size(); i++){
            Predicate pred = body.get(i);
            sql += pred.fromCls();
            if (i < body.size() - 1){
                sql += ", ";
            }
        }
        String where_cls = "";
        where_cls += " WHERE ";
        // get the joins
        Vector<Vector<Argument>> joins = getJoins();
        for (int i = 0; i < joins.size(); i++){
            Vector<Argument> join = joins.get(i);
            Argument arg1 = join.get(0);
            Predicate pred1 = allPredicates.get(arg1.predict_id);
            for(int j = 1; j < join.size(); j++){
                Argument arg = join.get(j);
                Predicate pred = allPredicates.get(arg.predict_id);
                where_cls += (pred.bodySelCls()+"."+pred.functor + "_" + (arg.position+1) + " = " + pred1.bodySelCls()+"."+pred1.functor + "_" + (arg1.position+1));
                if (j < join.size() - 1){
                    where_cls += " AND ";
                }
            }
        }
        // get all the constants predicates 
        for (int i = 0; i < constantsBody.size(); i++){

            Argument constant = constantsBody.get(i);
            Predicate pred = allPredicates.get(constant.predict_id);
            where_cls += (pred.bodySelCls()+"."+pred.functor + "_" + (constant.position+1) + " = " + "\'" + constant.name + "\'");
            if (i < constantsBody.size() - 1){
                where_cls += " AND ";
            }
        }
        // for all the body predicates, the exists column must be 1
        for (int i = 0; i < body.size(); i++){
            Predicate pred = body.get(i);
            where_cls += " AND " + pred.bodySelCls() + ".exists = 1";
        }

        
        if (!(joins.size() == 0 && constantsBody.size() == 0)){
            sql += where_cls;
        }
        // sql += ";";
        return sql;
    }
    public String ruleHead2SQL_tmp(){
        // Argument:
        // tag: whether to add the tag "exists = 1" in the where clause
        // query: whether to query the body predicates
        // target_gold: confirm the query result is consistent with the target_gold. actually, the constant in the head is in the body. Its redundant.
        String sql = "SELECT ";
        String target_functor = head.functor;
        // get the head Arguments and Constant
        Argument[] head_args = head.args;
        for (int i = 0; i < head_args.length; i++){
            Argument arg = head_args[i];
            if (arg.isConstant){
                sql += ("\'" + arg.name+ "\'" + " AS " + target_functor + "_" + (i+1));
            }else{
                Argument target_arg;
                try{
                    target_arg = joinMap.get(arg.name).get(0);
                    Predicate target_pred = allPredicates.get(target_arg.predict_id);
                    sql += (target_pred.bodySelCls()+"."+target_pred.functor+'_'+(target_arg.position+1) + " AS " + target_functor + "_" + (i+1));
                    
                }catch(Exception e){
                    System.out.println("arg.name: " + arg.name);
                }
            }
            if (i < head_args.length - 1){
                sql += ", ";
            }
        }

        String outer_sql = "SELECT ";
        for(int j = 0; j < head_args.length; j++){
            outer_sql += "TMP."+target_functor + "_" + (j+1) + " AS " + "tmp_" + (j+1);
            outer_sql += ", ";
        }
        outer_sql += "\'"+head.functor+"\' AS source_table FROM (";
    
        sql += rule2SQL_where(false);
        String sql_outer = outer_sql + sql + ") AS TMP WHERE EXISTS ( SELECT 1 FROM " + target_functor + " WHERE";
        // the where clause is formed like: where target_functor_1 = TMP.target_functor_1 AND target_functor_2 = TMP.target_functor_2 AND ...)
        for (int i = 0; i < head_args.length; i++){
            sql_outer += " " + target_functor + "_" + (i+1) + " = TMP." + target_functor + "_" + (i+1);
            if (i < head_args.length - 1){
                sql_outer += " AND";
            }
        }
        return sql_outer+" );";
    }
    public String ruleHead2SQL_Set(){
        /*
         * query the infered tuple in head and body of rule.
         */
        String sql = "SELECT ";
        String target_functor = head.functor;
        Argument[] head_args = head.args;
        for (int i = 0; i < head_args.length; i++){ // 
            Argument arg = head_args[i];
            if (arg.isConstant){
                sql += ("\'" + arg.name+ "\'" + " AS " + target_functor + "_" + (i+1));
            }else{
                try{
                    Argument target_arg = joinMap.get(arg.name).get(0);
                    Predicate target_pred = allPredicates.get(target_arg.predict_id);
                    sql += (target_pred.bodySelCls()+"."+target_pred.functor+'_'+(target_arg.position+1) + " AS " + target_functor + "_" + (i+1));
                }catch(Exception e){
                    throw e;
                }
            }
            if (i < head_args.length - 1){
                sql += ", ";
            }
        }
        sql += ", ";
        for (int i = 0; i < body.size(); i++){
            Predicate pred = body.get(i);
            for(int j = 0; j < pred.args.length; j++){
                sql += pred.bodySelCls()+"."+pred.functor + "_" + (j+1);
                sql += ", ";
            }
        }

        if(sql.endsWith(", ")){
            sql = sql.substring(0, sql.length()-2);
        }
        if(sql.equals("SELECT ")){
            sql += " * ";
        }
    
        sql += rule2SQL_where(false);
        return sql;
    }

    public String ruleHead2SQL(int pad, int rule_id){
        // Argument:
        // tag: whether to add the tag "exists = 1" in the where clause
        // query: whether to query the body predicates
        // target_gold: confirm the query result is consistent with the target_gold. actually, the constant in the head is in the body. Its redundant.
        String sql = "SELECT ";
        String target_functor = head.functor;
        // get the head Arguments and Constant
        Argument[] head_args = head.args;
        if(rule_id>=0){
            sql+= rule_id + " AS rule_id, ";
        }
        for (int i = 0; i < head_args.length; i++){
            Argument arg = head_args[i];
            if (arg.isConstant){
                sql += ("\'" + arg.name+ "\'" + " AS " + target_functor + "_" + (i+1));
            }else{
                Argument target_arg;
                try{
                    target_arg = joinMap.get(arg.name).get(0);
                    Predicate target_pred = allPredicates.get(target_arg.predict_id);
                    sql += (target_pred.bodySelCls()+"."+target_pred.functor+'_'+(target_arg.position+1) + " AS " + target_functor + "_" + (i+1));
                }catch(Exception e){
                    System.out.println("arg.name: " + arg.name);
                }
                

            }
            if (i < head_args.length - 1){
                sql += ", ";
            }
        }
        sql += ", ";
        for (int i = 0; i < body.size(); i++){
            Predicate pred = body.get(i);
            for(int j = 0; j < pred.args.length; j++){
                sql += pred.bodySelCls()+"."+pred.functor + "_" + (j+1);
                sql += ", ";
            }
        }
        // if the number of target columns less than pad, fill the rest with null
        for (int i = 0; i < pad - argSize(); i++){
            sql += "NULL AS pad_" + i;
            if (i < pad - argSize() - 1){
                sql += ", ";
            }
        }
        if(sql.endsWith(", ")){
            sql = sql.substring(0, sql.length()-2);
        }
        if(sql.equals("SELECT ")){
            sql += " * ";
        }
    
        sql += rule2SQL_where(false);

        String sql_outer = "SELECT * FROM (" + sql + ") AS TMP WHERE EXISTS ( SELECT 1 FROM " + target_functor + " WHERE";
        // the where clause is formed like: where target_functor_1 = TMP.target_functor_1 AND target_functor_2 = TMP.target_functor_2 AND ...)
        for (int i = 0; i < head_args.length; i++){
            sql_outer += " " + target_functor + "_" + (i+1) + " = TMP." + target_functor + "_" + (i+1);
            if (i < head_args.length - 1){
                sql_outer += " AND";
            }
        }
        return sql_outer+" );";
    }
    public String rule2SQL(boolean tag, boolean query){
        // Argument:
        // tag: whether to add the tag "exists = 1" in the where clause
        // query: whether to query the body predicates
        // target_gold: confirm the query result is consistent with the target_gold. actually, the constant in the head is in the body. Its redundant.
        // produce form like :
        // SELECT body1.functor_1 as target_func_1, body2.functor_2 as target_func_2, ... 
        //  [if query]: SELECT body1.functor_1, body1.functor_2, body2.functor_1, body2.functor_2, ... 
        //  FROM body1, body2 
        //      WHERE body1.functor_1 = body2.functor_1 AND body1.functor_2 = body2.functor_2 AND ...
        //          [if tag]: AND body1.exists = 1 AND body2.exists = 1 AND ...
        String sql = "SELECT ";
        if(query){ // query the body predicates
            // rename the duplicate columns in body predicates
            for (int i = 0; i < body.size(); i++){
                Predicate pred = body.get(i);
                for(int j = 0; j < pred.args.length; j++){
                    sql += pred.bodySelCls()+"."+pred.functor + "_" + (j+1);
                    sql += ", ";
                }
            }
            if(sql.endsWith(", ")){
                sql = sql.substring(0, sql.length()-2);
            }
            if(sql.equals("SELECT ")){
                sql += " * ";
            }
        }
        else{  // rename the query result to rule's head
            String target_functor = head.functor;
            // get the head Arguments and Constant
            Argument[] head_args = head.args;
            for (int i = 0; i < head_args.length; i++){
                Argument arg = head_args[i];
                if (arg.isConstant){
                    sql += ("\'" + arg.name+ "\'" + " AS " + target_functor + "_" + (i+1));
                }else{
                    Argument target_arg;
                    try{
                        target_arg = joinMap.get(arg.name).get(0);
                        Predicate target_pred = allPredicates.get(target_arg.predict_id);
                        sql += (target_pred.bodySelCls()+"."+target_pred.functor+'_'+(target_arg.position+1) + " AS " + target_functor + "_" + (i+1));
                    }catch(Exception e){
                        System.out.println("arg.name: " + arg.name);
                    }
                }
                if (i < head_args.length - 1){
                    sql += ", ";
                }
            }
        }
        sql += rule2SQL_where(tag);
        // sql += ";";
        return sql;
    }

    public String rule2SQL(boolean tag, boolean query, int[] target_gold){
        // Argument:
        // tag: whether to add the tag "exists = 1" in the where clause
        // query: whether to query the body predicates
        // target_gold: confirm the query result is consistent with the target_gold. actually, the constant in the head is in the body. Its redundant.
        String sql = "SELECT ";
        if(query){ // query the body predicates
            // rename the duplicate columns in body predicates
            for (int i = 0; i < body.size(); i++){
                Predicate pred = body.get(i);
                for(int j = 0; j < pred.args.length; j++){
                    sql += pred.bodySelCls()+"."+pred.functor + "_" + (j+1);
                    sql += ", ";
                }
            }
            if(sql.endsWith(", ")){
                sql = sql.substring(0, sql.length()-2);
            }
            if(sql.equals("SELECT ")){
                sql += " * ";
            }
        }
        else{  // rename the query result to rule's head
            String target_functor = head.functor;
            // get the head Arguments and Constant
            Argument[] head_args = head.args;
            for (int i = 0; i < head_args.length; i++){
                Argument arg = head_args[i];
                if (arg.isConstant){
                    sql += ("\'" + arg.name+ "\'" + " AS " + target_functor + "_" + (i+1));
                }else{
                    Argument target_arg;
                    try{
                        target_arg = joinMap.get(arg.name).get(0);
                        Predicate target_pred = allPredicates.get(target_arg.predict_id);
                        sql += (target_pred.bodySelCls()+"."+target_pred.functor+'_'+(target_arg.position+1) + " AS " + target_functor + "_" + (i+1));
                    }catch(Exception e){
                        System.out.println("arg.name: " + arg.name);
                    }
                }
                if (i < head_args.length - 1){
                    sql += ", ";
                }
            }
        }
        sql += rule2SQL_where(tag, target_gold);
        // sql += ";";
        return sql;
    }

    public int argSize(){
        // get the number of arguments in the rule
        int size = 0;
        for (Predicate pred : body){
            size += pred.args.length;
        }
        size += head.args.length;
        return size;
    }
    // ????
    public boolean isValid(){

        for(Argument arg: head.args){
            if(arg.name.contains("me_myself_i")){
                return false;
            }
        }
        for(Predicate pred: body){
            for(Argument arg: pred.args){
                if(arg.name.contains("me_myself_i")){
                    return false;
                }
            }
        }
        return true;
    }
}
